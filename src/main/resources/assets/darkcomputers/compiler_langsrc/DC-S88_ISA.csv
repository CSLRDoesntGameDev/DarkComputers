0x0001,Data,MOV,"SRC, DST, IGN",,R[DST] = R[SRC]
0x0002,Data,LDI,"DST, IMM, IGN",,R[DST] = SXT(IMM)
0x0003,Data,LDR,"DST, SRC, IMM",,R[DST] = SXT(M[R[SRC] + SXT(IMM)] & 0xFF)
0x0004,Data,STR,"SRC, DST, IMM",,M[R[DST] + SXT(IMM)] = (R[SRC] & 0xFF)
0x0005,Data,CPR,"SRC, DST, IMM",,M[RANGE(DST + SXT(IMM))] = M[RANGE(SRC + SXT(IMM))]
0x0006,Math,ADD,"DST, SRCa, SRCb",,R[DST] = R[SRCa] + R[SRCb]
0x0007,Math,SUB,"DST, SRCa, SRCb",,R[DST] = R[SRCa] - R[SRCb]
0x0008,Math,MUL,"DST, SRCa, SRCb",,R[DST] = R[SRCa] * R[SRCb]
0x0009,Math,DIV,"DST, SRCa, SRCb",,R[DST] = R[SRCa] / R[SRCb]
0x000A,Math,MOD,"DST, SRCa, SRCb",,R[DST] = R[SRCa] % R[SRCb]
0x000B,Math,NEG,"DST, SRC, SRC",,R[DST] = -R[SRC]
0x000C,Math,NOT,"DST, SRC, IGN",,R[DST] = ~R[SRC]
0x000D,Logic,AND,"DST, SRCa, SRCb",,R[DST] = R[SRCa] & R[SRCb]
0x000E,Logic,OR,"DST, SRCa, SRCb",,R[DST] = R[SRCa] | R[SRCb]
0x000F,Logic,XOR,"DST, SRCa, SRCb",,R[DST] = R[SRCa] ^ R[SRCb]
0x0010,Logic,SHL,"DST, SRCa, SRCb",,R[DST] = R[SRCa] <<  R[SRCb]
0x0011,Logic,SHR,"DST, SRCa, SRCb",,R[DST] = R[SRCa] >> R[SRCb]
0x0012,Control,JMP,"DST, IGN, IGN",,PC = DST
0x0013,Control,JSR,"DST, IGN, IGN",,PUSH(PC); PC = DST
0x0014,Control,JIP,"DST, SRC, IGN",,if (R[SRC] > 0) JSR(DST)
0x0015,Control,RET,"IGN, IGN, IGN",,PC = POP()
0x0016,Control,HLT,"IGN, IGN, IGN",,Halts the CPU
0x0017,Control,WAT,"IMM, IGN, IGN",,Halts the CPU for a give amount of cycles
0x0018,Condition,EQ,"DST, SRCa, SRCb",,R[DST] = (R[SRCa] == R[SRCb]) ? 1 : 0
0x0019,Condition,NEQ,"DST, SRCa, SRCb",,R[DST] = (R[SRCa] != R[SRCb]) ? 1 : 0
0x001A,Condition,LT,"DST, SRCa, SRCb",,R[DST] = (R[SRCa] < R[SRCb]) ? 1 : 0
0x001B,Condition,GT,"DST, SRCa, SRCb",,R[DST] = (R[SRCa] > R[SRCb]) ? 1 : 0
0x001C,Condition,LE,"DST, SRCa, SRCb",,R[DST] = (R[SRCa] <= R[SRCb]) ? 1 : 0
0x001D,Condition,GE,"DST, SRCa, SRCb",,R[DST] = (R[SRCa] >= R[SRCb]) ? 1 : 0
0x001E,Stack,PSH,"SRC, IGN, IGN",,SP += 1; S[SP] = R[SRC]
0x001F,Stack,POP,"DST, IGN, IGN",,SP -= 1; R[DST] = S[SP]